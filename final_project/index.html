<html>

<head>
  <style>
    html,
    body {
      background-color: #000000;
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden !important;
    }
  </style>

  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@latest/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
      }
    }
    </script>

  <script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    var renderer, controls, scene, camera;
    let controller1, controller1Grip, controller2, controller2Grip;
    let globalGroup = new THREE.Group();
    let FPS = 1 / 60;
    let GRAVITY = 9.81;
    let BALLS = [];
    let PLATES = [];
    let MAX_PLATES = 7;
    let PLATE_CD = 120;
    let CURR_PLATE_CD = 0;
    function MeshObjects(mesh) {
      this.object = mesh;
      this.PHYSICS = {
        "yspeed": 0,
        "yspeedint": 0,
        "xspeed": 0,
        "zspeed": 0,
        "time": 0,
      }
    }


    window.onload = function () {

      // Three.js code goes here
      scene = new THREE.Scene({ antialias: true });
      scene.add(globalGroup);

      // setup the camera
      var fov = 75;
      var ratio = window.innerWidth / window.innerHeight;
      var zNear = 0.1;
      var zFar = 10000;
      camera = new THREE.PerspectiveCamera(fov, ratio, zNear, zFar);
      camera.position.set(0, 0, 0);

      // create renderer and add canvas to DOM
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Configure VR Support
      document.body.appendChild(VRButton.createButton(renderer));
      renderer.xr.enabled = true;
      renderer.setAnimationLoop(animate);

      const line = new THREE.Line(
        new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]),
        new THREE.LineBasicMaterial({ color: 0xff0000 })
      );
      line.scale.z = 5;

      // VR controls 
      const controllerModelFactory = new XRControllerModelFactory();

      controller1Grip = renderer.xr.getControllerGrip(0);
      controller1Grip.add(controllerModelFactory.createControllerModel(controller1Grip));
      scene.add(controller1Grip);
      controller1 = renderer.xr.getController(0);
      controller1.add(line.clone());
      scene.add(controller1);
      controller1.userData.prevPos = new THREE.Vector3();
      controller1.userData.prevQuat = new THREE.Quaternion();

      controller2Grip = renderer.xr.getControllerGrip(1);
      controller2Grip.add(controllerModelFactory.createControllerModel(controller2Grip));
      scene.add(controller2Grip);
      controller2 = renderer.xr.getController(1);
      controller2.add(line.clone());
      scene.add(controller2);

      console.log(controller1Grip);

      // Controller Squeeze event
      controller1.addEventListener('selectstart', (event) => {
        let controller = event.target;
        let geometry = new THREE.SphereGeometry(0.2, 32, 16);
        let material = new THREE.MeshStandardMaterial({ color: 0xffffff, wireframe: false });
        let ball = new THREE.Mesh(geometry, material);
        let object = new MeshObjects(ball);
        controller1.add(ball);
        ball.position.set(0, 0, 0);
        controller1.userData.prevPos = controller1.position.clone();
        controller1.userData.prevQuat = controller1.quaternion.clone();
        controller.userData.selected = object;
      });

      controller1.addEventListener('selectend', (event) => {
        let controller = event.target;
        let object = controller.userData.selected;
        if (object !== undefined) {
          let sphere = object.object;
          let position = new THREE.Vector3();
          sphere.getWorldPosition(position);
          globalGroup.add(sphere);
          sphere.position.x = position.x;
          sphere.position.y = position.y;
          sphere.position.z = position.z;
          const prevPos = controller.userData.prevPos;
          const prevQuat = controller.userData.prevQuat;
          const currPos = controller.position;
          const currQuat = controller.quaternion;
          // Change in Quaternion: From ChatGPT
          let deltaQuat =  new THREE.Quaternion().multiplyQuaternions(currQuat.clone(), prevQuat.clone().invert())
          let angularVelocity = {
            x: 2 * deltaQuat.x / FPS,
            y: 2 * deltaQuat.y / FPS,
            z: 2 * deltaQuat.z / FPS,
          }
          console.log(angularVelocity);
          let crossProd = new THREE.Vector3(angularVelocity.x, angularVelocity.y, angularVelocity.z).cross(new THREE.Vector3(position.x, position.y, position.z));
          object.PHYSICS.xspeed = ((currPos.x - prevPos.x) / FPS) + crossProd.x;
          object.PHYSICS.zspeed = ((currPos.z - prevPos.z) / FPS) + crossProd.z;
          object.PHYSICS.yspeedint = ((currPos.y - prevPos.y) / FPS) + crossProd.y;
          console.log(currPos, prevPos);
          BALLS.push(object);
          console.log(object);
          controller.userData.selected = undefined;
          controller.userData.prevPos = new THREE.Vector3();
          controller1.userData.prevQuat = new THREE.Quaternion();
        }
      });

      //setup lights
      var ambientLight = new THREE.AmbientLight();
      scene.add(ambientLight);

      var light = new THREE.DirectionalLight(0xeeaf61, 5.0);
      light.position.set(100, 20, 0);
      scene.add(light);

      // Create floor

      let floorGeometry = new THREE.PlaneGeometry(1000, 1000, 15, 15);
      let floorMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, wireframe: false });
      floorMaterial.side = THREE.DoubleSide;
      let floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.position.set(0, -10, 0);
      floor.rotation.x = Math.PI / 2;

      scene.add(floor);


      //configure Sphere
      var geometry = new THREE.SphereGeometry(5, 32, 16);
      var material = new THREE.MeshStandardMaterial({ color: 0x7851A9, wireframe: false });

      var sphere = new THREE.Mesh(geometry, material);
      sphere.translateZ(-50);
      sphere.translateY(20);
      scene.add(sphere);
      let object = new MeshObjects(sphere);
      BALLS.push(object);
      console.log(object);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enable;
      controls.update();

    };
    function createPlate() {
      let geometry = new THREE.CircleGeometry(5, 32);
      let material = new THREE.MeshStandardMaterial({ color: 0x7851A9, wireframe: false });
      let plate = new THREE.Mesh(geometry, material);
      plate.translateZ(-50);
      plate.translateY(20);
      scene.add(plate);
      let object = new MeshObjects(plate);
      object.PHYSICS = {
        "yspeed": 0,
        "yspeedint": 0,
        "xspeed": 5,
        "zspeed": 0,
        "time": 0,
      }
      PLATES.push(object);

    }
    function animate() {
      controller1.userData.prevPos = controller1.position.clone();
      controller1.userData.prevQuat = controller1.quaternion.clone();
      if (PLATES.length < MAX_PLATES && CURR_PLATE_CD <= 0) {
        CURR_PLATE_CD = PLATE_CD;
        createPlate();
      } else {
        CURR_PLATE_CD -= 1;
      }
      for (let i = 0; i < PLATES.length; i++) {
        let plate_mesh_object = PLATES[i];
        let plate = plate_mesh_object.object;
        let plate_physics = plate_mesh_object.PHYSICS;
        let xdisplacement = plate_physics.xspeed * FPS;
        plate.position.x += xdisplacement;
      }
      for (let i = 0; i < BALLS.length; i++) {
        let ball_mesh_object = BALLS[i];
        let ball = BALLS[i].object;
        let ball_physics = ball_mesh_object.PHYSICS;
        if (ball.position.y > -5) {
          ball_physics.time += FPS;
          let ydisplacement = 0;
          ball_physics.yspeed = ball_physics.yspeedint - GRAVITY * ball_physics.time;
          ydisplacement = ball_physics.yspeed * FPS + (0.5 * - GRAVITY * Math.pow(ball_physics.time, 2));
          if (ball.position.y - ydisplacement < -5) {
            ball.position.y = -5;
          } else {
            ball.position.y += ydisplacement;
          }
          let xdisplacement = ball_physics.xspeed * FPS;
          ball.position.x += xdisplacement;
          let zdisplacement = ball_physics.zspeed * FPS;
          ball.position.z += zdisplacement;
        } else {
          ball_physics.yspeed = 0;
          ball_physics.yspeedint = 0;
          ball_physics.time = 0;
        }
      }
      renderer.render(scene, camera);
    };
  </script>
</head>

<body></body>

</html>